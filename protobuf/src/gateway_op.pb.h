// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gateway_op.proto

#ifndef PROTOBUF_gateway_5fop_2eproto__INCLUDED
#define PROTOBUF_gateway_5fop_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace nway_fs_opterator {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_gateway_5fop_2eproto();
void protobuf_AssignDesc_gateway_5fop_2eproto();
void protobuf_ShutdownFile_gateway_5fop_2eproto();

class nway_gateway;
class get_nway_gateways_req;
class get_nway_gateways_rsp;
class add_nway_gateway_req;
class add_nway_gateway_rsp;
class edit_nway_gateway_req;
class edit_nway_gateway_rsp;
class erase_nway_gateway_req;
class erase_nway_gateway_rsp;
class reload_gateway_req;
class reload_gateway_rsp;

enum nway_op_status {
  success = 1,
  failed = 2,
  notfound = 3,
  unknow = 4
};
bool nway_op_status_IsValid(int value);
const nway_op_status nway_op_status_MIN = success;
const nway_op_status nway_op_status_MAX = unknow;
const int nway_op_status_ARRAYSIZE = nway_op_status_MAX + 1;

const ::google::protobuf::EnumDescriptor* nway_op_status_descriptor();
inline const ::std::string& nway_op_status_Name(nway_op_status value) {
  return ::google::protobuf::internal::NameOfEnum(
    nway_op_status_descriptor(), value);
}
inline bool nway_op_status_Parse(
    const ::std::string& name, nway_op_status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<nway_op_status>(
    nway_op_status_descriptor(), name, value);
}
// ===================================================================

class nway_gateway : public ::google::protobuf::Message {
 public:
  nway_gateway();
  virtual ~nway_gateway();

  nway_gateway(const nway_gateway& from);

  inline nway_gateway& operator=(const nway_gateway& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const nway_gateway& default_instance();

  void Swap(nway_gateway* other);

  // implements Message ----------------------------------------------

  nway_gateway* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const nway_gateway& from);
  void MergeFrom(const nway_gateway& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string gateway_name = 1;
  inline bool has_gateway_name() const;
  inline void clear_gateway_name();
  static const int kGatewayNameFieldNumber = 1;
  inline const ::std::string& gateway_name() const;
  inline void set_gateway_name(const ::std::string& value);
  inline void set_gateway_name(const char* value);
  inline void set_gateway_name(const char* value, size_t size);
  inline ::std::string* mutable_gateway_name();
  inline ::std::string* release_gateway_name();
  inline void set_allocated_gateway_name(::std::string* gateway_name);

  // optional string username = 2;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 2;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional string realm = 3;
  inline bool has_realm() const;
  inline void clear_realm();
  static const int kRealmFieldNumber = 3;
  inline const ::std::string& realm() const;
  inline void set_realm(const ::std::string& value);
  inline void set_realm(const char* value);
  inline void set_realm(const char* value, size_t size);
  inline ::std::string* mutable_realm();
  inline ::std::string* release_realm();
  inline void set_allocated_realm(::std::string* realm);

  // optional string from_user = 4;
  inline bool has_from_user() const;
  inline void clear_from_user();
  static const int kFromUserFieldNumber = 4;
  inline const ::std::string& from_user() const;
  inline void set_from_user(const ::std::string& value);
  inline void set_from_user(const char* value);
  inline void set_from_user(const char* value, size_t size);
  inline ::std::string* mutable_from_user();
  inline ::std::string* release_from_user();
  inline void set_allocated_from_user(::std::string* from_user);

  // optional string from_domain = 5;
  inline bool has_from_domain() const;
  inline void clear_from_domain();
  static const int kFromDomainFieldNumber = 5;
  inline const ::std::string& from_domain() const;
  inline void set_from_domain(const ::std::string& value);
  inline void set_from_domain(const char* value);
  inline void set_from_domain(const char* value, size_t size);
  inline ::std::string* mutable_from_domain();
  inline ::std::string* release_from_domain();
  inline void set_allocated_from_domain(::std::string* from_domain);

  // optional string password = 6;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 6;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional string extension = 7;
  inline bool has_extension() const;
  inline void clear_extension();
  static const int kExtensionFieldNumber = 7;
  inline const ::std::string& extension() const;
  inline void set_extension(const ::std::string& value);
  inline void set_extension(const char* value);
  inline void set_extension(const char* value, size_t size);
  inline ::std::string* mutable_extension();
  inline ::std::string* release_extension();
  inline void set_allocated_extension(::std::string* extension);

  // optional string proxy = 8;
  inline bool has_proxy() const;
  inline void clear_proxy();
  static const int kProxyFieldNumber = 8;
  inline const ::std::string& proxy() const;
  inline void set_proxy(const ::std::string& value);
  inline void set_proxy(const char* value);
  inline void set_proxy(const char* value, size_t size);
  inline ::std::string* mutable_proxy();
  inline ::std::string* release_proxy();
  inline void set_allocated_proxy(::std::string* proxy);

  // optional string expire_seconds = 9;
  inline bool has_expire_seconds() const;
  inline void clear_expire_seconds();
  static const int kExpireSecondsFieldNumber = 9;
  inline const ::std::string& expire_seconds() const;
  inline void set_expire_seconds(const ::std::string& value);
  inline void set_expire_seconds(const char* value);
  inline void set_expire_seconds(const char* value, size_t size);
  inline ::std::string* mutable_expire_seconds();
  inline ::std::string* release_expire_seconds();
  inline void set_allocated_expire_seconds(::std::string* expire_seconds);

  // optional string register = 10;
  inline bool has_register_() const;
  inline void clear_register_();
  static const int kRegisterFieldNumber = 10;
  inline const ::std::string& register_() const;
  inline void set_register_(const ::std::string& value);
  inline void set_register_(const char* value);
  inline void set_register_(const char* value, size_t size);
  inline ::std::string* mutable_register_();
  inline ::std::string* release_register_();
  inline void set_allocated_register_(::std::string* register_);

  // optional string register_transport = 11;
  inline bool has_register_transport() const;
  inline void clear_register_transport();
  static const int kRegisterTransportFieldNumber = 11;
  inline const ::std::string& register_transport() const;
  inline void set_register_transport(const ::std::string& value);
  inline void set_register_transport(const char* value);
  inline void set_register_transport(const char* value, size_t size);
  inline ::std::string* mutable_register_transport();
  inline ::std::string* release_register_transport();
  inline void set_allocated_register_transport(::std::string* register_transport);

  // optional string retry_seconds = 12;
  inline bool has_retry_seconds() const;
  inline void clear_retry_seconds();
  static const int kRetrySecondsFieldNumber = 12;
  inline const ::std::string& retry_seconds() const;
  inline void set_retry_seconds(const ::std::string& value);
  inline void set_retry_seconds(const char* value);
  inline void set_retry_seconds(const char* value, size_t size);
  inline ::std::string* mutable_retry_seconds();
  inline ::std::string* release_retry_seconds();
  inline void set_allocated_retry_seconds(::std::string* retry_seconds);

  // optional string caller_id_in_from = 13;
  inline bool has_caller_id_in_from() const;
  inline void clear_caller_id_in_from();
  static const int kCallerIdInFromFieldNumber = 13;
  inline const ::std::string& caller_id_in_from() const;
  inline void set_caller_id_in_from(const ::std::string& value);
  inline void set_caller_id_in_from(const char* value);
  inline void set_caller_id_in_from(const char* value, size_t size);
  inline ::std::string* mutable_caller_id_in_from();
  inline ::std::string* release_caller_id_in_from();
  inline void set_allocated_caller_id_in_from(::std::string* caller_id_in_from);

  // optional string contact_params = 14;
  inline bool has_contact_params() const;
  inline void clear_contact_params();
  static const int kContactParamsFieldNumber = 14;
  inline const ::std::string& contact_params() const;
  inline void set_contact_params(const ::std::string& value);
  inline void set_contact_params(const char* value);
  inline void set_contact_params(const char* value, size_t size);
  inline ::std::string* mutable_contact_params();
  inline ::std::string* release_contact_params();
  inline void set_allocated_contact_params(::std::string* contact_params);

  // optional string ping = 15;
  inline bool has_ping() const;
  inline void clear_ping();
  static const int kPingFieldNumber = 15;
  inline const ::std::string& ping() const;
  inline void set_ping(const ::std::string& value);
  inline void set_ping(const char* value);
  inline void set_ping(const char* value, size_t size);
  inline ::std::string* mutable_ping();
  inline ::std::string* release_ping();
  inline void set_allocated_ping(::std::string* ping);

  // optional string filename = 16;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 16;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional string register_proxy = 17;
  inline bool has_register_proxy() const;
  inline void clear_register_proxy();
  static const int kRegisterProxyFieldNumber = 17;
  inline const ::std::string& register_proxy() const;
  inline void set_register_proxy(const ::std::string& value);
  inline void set_register_proxy(const char* value);
  inline void set_register_proxy(const char* value, size_t size);
  inline ::std::string* mutable_register_proxy();
  inline ::std::string* release_register_proxy();
  inline void set_allocated_register_proxy(::std::string* register_proxy);

  // @@protoc_insertion_point(class_scope:nway_fs_opterator.nway_gateway)
 private:
  inline void set_has_gateway_name();
  inline void clear_has_gateway_name();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_realm();
  inline void clear_has_realm();
  inline void set_has_from_user();
  inline void clear_has_from_user();
  inline void set_has_from_domain();
  inline void clear_has_from_domain();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_extension();
  inline void clear_has_extension();
  inline void set_has_proxy();
  inline void clear_has_proxy();
  inline void set_has_expire_seconds();
  inline void clear_has_expire_seconds();
  inline void set_has_register_();
  inline void clear_has_register_();
  inline void set_has_register_transport();
  inline void clear_has_register_transport();
  inline void set_has_retry_seconds();
  inline void clear_has_retry_seconds();
  inline void set_has_caller_id_in_from();
  inline void clear_has_caller_id_in_from();
  inline void set_has_contact_params();
  inline void clear_has_contact_params();
  inline void set_has_ping();
  inline void clear_has_ping();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_register_proxy();
  inline void clear_has_register_proxy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* gateway_name_;
  ::std::string* username_;
  ::std::string* realm_;
  ::std::string* from_user_;
  ::std::string* from_domain_;
  ::std::string* password_;
  ::std::string* extension_;
  ::std::string* proxy_;
  ::std::string* expire_seconds_;
  ::std::string* register__;
  ::std::string* register_transport_;
  ::std::string* retry_seconds_;
  ::std::string* caller_id_in_from_;
  ::std::string* contact_params_;
  ::std::string* ping_;
  ::std::string* filename_;
  ::std::string* register_proxy_;
  friend void  protobuf_AddDesc_gateway_5fop_2eproto();
  friend void protobuf_AssignDesc_gateway_5fop_2eproto();
  friend void protobuf_ShutdownFile_gateway_5fop_2eproto();

  void InitAsDefaultInstance();
  static nway_gateway* default_instance_;
};
// -------------------------------------------------------------------

class get_nway_gateways_req : public ::google::protobuf::Message {
 public:
  get_nway_gateways_req();
  virtual ~get_nway_gateways_req();

  get_nway_gateways_req(const get_nway_gateways_req& from);

  inline get_nway_gateways_req& operator=(const get_nway_gateways_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const get_nway_gateways_req& default_instance();

  void Swap(get_nway_gateways_req* other);

  // implements Message ----------------------------------------------

  get_nway_gateways_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const get_nway_gateways_req& from);
  void MergeFrom(const get_nway_gateways_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string falg = 1;
  inline bool has_falg() const;
  inline void clear_falg();
  static const int kFalgFieldNumber = 1;
  inline const ::std::string& falg() const;
  inline void set_falg(const ::std::string& value);
  inline void set_falg(const char* value);
  inline void set_falg(const char* value, size_t size);
  inline ::std::string* mutable_falg();
  inline ::std::string* release_falg();
  inline void set_allocated_falg(::std::string* falg);

  // required int32 start_pos = 2;
  inline bool has_start_pos() const;
  inline void clear_start_pos();
  static const int kStartPosFieldNumber = 2;
  inline ::google::protobuf::int32 start_pos() const;
  inline void set_start_pos(::google::protobuf::int32 value);

  // required int32 number_per_page = 3;
  inline bool has_number_per_page() const;
  inline void clear_number_per_page();
  static const int kNumberPerPageFieldNumber = 3;
  inline ::google::protobuf::int32 number_per_page() const;
  inline void set_number_per_page(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:nway_fs_opterator.get_nway_gateways_req)
 private:
  inline void set_has_falg();
  inline void clear_has_falg();
  inline void set_has_start_pos();
  inline void clear_has_start_pos();
  inline void set_has_number_per_page();
  inline void clear_has_number_per_page();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* falg_;
  ::google::protobuf::int32 start_pos_;
  ::google::protobuf::int32 number_per_page_;
  friend void  protobuf_AddDesc_gateway_5fop_2eproto();
  friend void protobuf_AssignDesc_gateway_5fop_2eproto();
  friend void protobuf_ShutdownFile_gateway_5fop_2eproto();

  void InitAsDefaultInstance();
  static get_nway_gateways_req* default_instance_;
};
// -------------------------------------------------------------------

class get_nway_gateways_rsp : public ::google::protobuf::Message {
 public:
  get_nway_gateways_rsp();
  virtual ~get_nway_gateways_rsp();

  get_nway_gateways_rsp(const get_nway_gateways_rsp& from);

  inline get_nway_gateways_rsp& operator=(const get_nway_gateways_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const get_nway_gateways_rsp& default_instance();

  void Swap(get_nway_gateways_rsp* other);

  // implements Message ----------------------------------------------

  get_nway_gateways_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const get_nway_gateways_rsp& from);
  void MergeFrom(const get_nway_gateways_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .nway_fs_opterator.nway_op_status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::nway_fs_opterator::nway_op_status status() const;
  inline void set_status(::nway_fs_opterator::nway_op_status value);

  // repeated .nway_fs_opterator.nway_gateway gateways = 2;
  inline int gateways_size() const;
  inline void clear_gateways();
  static const int kGatewaysFieldNumber = 2;
  inline const ::nway_fs_opterator::nway_gateway& gateways(int index) const;
  inline ::nway_fs_opterator::nway_gateway* mutable_gateways(int index);
  inline ::nway_fs_opterator::nway_gateway* add_gateways();
  inline const ::google::protobuf::RepeatedPtrField< ::nway_fs_opterator::nway_gateway >&
      gateways() const;
  inline ::google::protobuf::RepeatedPtrField< ::nway_fs_opterator::nway_gateway >*
      mutable_gateways();

  // @@protoc_insertion_point(class_scope:nway_fs_opterator.get_nway_gateways_rsp)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::nway_fs_opterator::nway_gateway > gateways_;
  int status_;
  friend void  protobuf_AddDesc_gateway_5fop_2eproto();
  friend void protobuf_AssignDesc_gateway_5fop_2eproto();
  friend void protobuf_ShutdownFile_gateway_5fop_2eproto();

  void InitAsDefaultInstance();
  static get_nway_gateways_rsp* default_instance_;
};
// -------------------------------------------------------------------

class add_nway_gateway_req : public ::google::protobuf::Message {
 public:
  add_nway_gateway_req();
  virtual ~add_nway_gateway_req();

  add_nway_gateway_req(const add_nway_gateway_req& from);

  inline add_nway_gateway_req& operator=(const add_nway_gateway_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const add_nway_gateway_req& default_instance();

  void Swap(add_nway_gateway_req* other);

  // implements Message ----------------------------------------------

  add_nway_gateway_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const add_nway_gateway_req& from);
  void MergeFrom(const add_nway_gateway_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .nway_fs_opterator.nway_gateway gateway = 1;
  inline bool has_gateway() const;
  inline void clear_gateway();
  static const int kGatewayFieldNumber = 1;
  inline const ::nway_fs_opterator::nway_gateway& gateway() const;
  inline ::nway_fs_opterator::nway_gateway* mutable_gateway();
  inline ::nway_fs_opterator::nway_gateway* release_gateway();
  inline void set_allocated_gateway(::nway_fs_opterator::nway_gateway* gateway);

  // @@protoc_insertion_point(class_scope:nway_fs_opterator.add_nway_gateway_req)
 private:
  inline void set_has_gateway();
  inline void clear_has_gateway();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::nway_fs_opterator::nway_gateway* gateway_;
  friend void  protobuf_AddDesc_gateway_5fop_2eproto();
  friend void protobuf_AssignDesc_gateway_5fop_2eproto();
  friend void protobuf_ShutdownFile_gateway_5fop_2eproto();

  void InitAsDefaultInstance();
  static add_nway_gateway_req* default_instance_;
};
// -------------------------------------------------------------------

class add_nway_gateway_rsp : public ::google::protobuf::Message {
 public:
  add_nway_gateway_rsp();
  virtual ~add_nway_gateway_rsp();

  add_nway_gateway_rsp(const add_nway_gateway_rsp& from);

  inline add_nway_gateway_rsp& operator=(const add_nway_gateway_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const add_nway_gateway_rsp& default_instance();

  void Swap(add_nway_gateway_rsp* other);

  // implements Message ----------------------------------------------

  add_nway_gateway_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const add_nway_gateway_rsp& from);
  void MergeFrom(const add_nway_gateway_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string gateway_name = 1;
  inline bool has_gateway_name() const;
  inline void clear_gateway_name();
  static const int kGatewayNameFieldNumber = 1;
  inline const ::std::string& gateway_name() const;
  inline void set_gateway_name(const ::std::string& value);
  inline void set_gateway_name(const char* value);
  inline void set_gateway_name(const char* value, size_t size);
  inline ::std::string* mutable_gateway_name();
  inline ::std::string* release_gateway_name();
  inline void set_allocated_gateway_name(::std::string* gateway_name);

  // required .nway_fs_opterator.nway_op_status status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::nway_fs_opterator::nway_op_status status() const;
  inline void set_status(::nway_fs_opterator::nway_op_status value);

  // optional string res_text = 3;
  inline bool has_res_text() const;
  inline void clear_res_text();
  static const int kResTextFieldNumber = 3;
  inline const ::std::string& res_text() const;
  inline void set_res_text(const ::std::string& value);
  inline void set_res_text(const char* value);
  inline void set_res_text(const char* value, size_t size);
  inline ::std::string* mutable_res_text();
  inline ::std::string* release_res_text();
  inline void set_allocated_res_text(::std::string* res_text);

  // @@protoc_insertion_point(class_scope:nway_fs_opterator.add_nway_gateway_rsp)
 private:
  inline void set_has_gateway_name();
  inline void clear_has_gateway_name();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_res_text();
  inline void clear_has_res_text();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* gateway_name_;
  ::std::string* res_text_;
  int status_;
  friend void  protobuf_AddDesc_gateway_5fop_2eproto();
  friend void protobuf_AssignDesc_gateway_5fop_2eproto();
  friend void protobuf_ShutdownFile_gateway_5fop_2eproto();

  void InitAsDefaultInstance();
  static add_nway_gateway_rsp* default_instance_;
};
// -------------------------------------------------------------------

class edit_nway_gateway_req : public ::google::protobuf::Message {
 public:
  edit_nway_gateway_req();
  virtual ~edit_nway_gateway_req();

  edit_nway_gateway_req(const edit_nway_gateway_req& from);

  inline edit_nway_gateway_req& operator=(const edit_nway_gateway_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const edit_nway_gateway_req& default_instance();

  void Swap(edit_nway_gateway_req* other);

  // implements Message ----------------------------------------------

  edit_nway_gateway_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const edit_nway_gateway_req& from);
  void MergeFrom(const edit_nway_gateway_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .nway_fs_opterator.nway_gateway gateway = 1;
  inline bool has_gateway() const;
  inline void clear_gateway();
  static const int kGatewayFieldNumber = 1;
  inline const ::nway_fs_opterator::nway_gateway& gateway() const;
  inline ::nway_fs_opterator::nway_gateway* mutable_gateway();
  inline ::nway_fs_opterator::nway_gateway* release_gateway();
  inline void set_allocated_gateway(::nway_fs_opterator::nway_gateway* gateway);

  // @@protoc_insertion_point(class_scope:nway_fs_opterator.edit_nway_gateway_req)
 private:
  inline void set_has_gateway();
  inline void clear_has_gateway();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::nway_fs_opterator::nway_gateway* gateway_;
  friend void  protobuf_AddDesc_gateway_5fop_2eproto();
  friend void protobuf_AssignDesc_gateway_5fop_2eproto();
  friend void protobuf_ShutdownFile_gateway_5fop_2eproto();

  void InitAsDefaultInstance();
  static edit_nway_gateway_req* default_instance_;
};
// -------------------------------------------------------------------

class edit_nway_gateway_rsp : public ::google::protobuf::Message {
 public:
  edit_nway_gateway_rsp();
  virtual ~edit_nway_gateway_rsp();

  edit_nway_gateway_rsp(const edit_nway_gateway_rsp& from);

  inline edit_nway_gateway_rsp& operator=(const edit_nway_gateway_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const edit_nway_gateway_rsp& default_instance();

  void Swap(edit_nway_gateway_rsp* other);

  // implements Message ----------------------------------------------

  edit_nway_gateway_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const edit_nway_gateway_rsp& from);
  void MergeFrom(const edit_nway_gateway_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string gateway_name = 1;
  inline bool has_gateway_name() const;
  inline void clear_gateway_name();
  static const int kGatewayNameFieldNumber = 1;
  inline const ::std::string& gateway_name() const;
  inline void set_gateway_name(const ::std::string& value);
  inline void set_gateway_name(const char* value);
  inline void set_gateway_name(const char* value, size_t size);
  inline ::std::string* mutable_gateway_name();
  inline ::std::string* release_gateway_name();
  inline void set_allocated_gateway_name(::std::string* gateway_name);

  // required .nway_fs_opterator.nway_op_status status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::nway_fs_opterator::nway_op_status status() const;
  inline void set_status(::nway_fs_opterator::nway_op_status value);

  // optional string res_text = 3;
  inline bool has_res_text() const;
  inline void clear_res_text();
  static const int kResTextFieldNumber = 3;
  inline const ::std::string& res_text() const;
  inline void set_res_text(const ::std::string& value);
  inline void set_res_text(const char* value);
  inline void set_res_text(const char* value, size_t size);
  inline ::std::string* mutable_res_text();
  inline ::std::string* release_res_text();
  inline void set_allocated_res_text(::std::string* res_text);

  // @@protoc_insertion_point(class_scope:nway_fs_opterator.edit_nway_gateway_rsp)
 private:
  inline void set_has_gateway_name();
  inline void clear_has_gateway_name();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_res_text();
  inline void clear_has_res_text();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* gateway_name_;
  ::std::string* res_text_;
  int status_;
  friend void  protobuf_AddDesc_gateway_5fop_2eproto();
  friend void protobuf_AssignDesc_gateway_5fop_2eproto();
  friend void protobuf_ShutdownFile_gateway_5fop_2eproto();

  void InitAsDefaultInstance();
  static edit_nway_gateway_rsp* default_instance_;
};
// -------------------------------------------------------------------

class erase_nway_gateway_req : public ::google::protobuf::Message {
 public:
  erase_nway_gateway_req();
  virtual ~erase_nway_gateway_req();

  erase_nway_gateway_req(const erase_nway_gateway_req& from);

  inline erase_nway_gateway_req& operator=(const erase_nway_gateway_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const erase_nway_gateway_req& default_instance();

  void Swap(erase_nway_gateway_req* other);

  // implements Message ----------------------------------------------

  erase_nway_gateway_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const erase_nway_gateway_req& from);
  void MergeFrom(const erase_nway_gateway_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .nway_fs_opterator.nway_gateway gateway = 1;
  inline bool has_gateway() const;
  inline void clear_gateway();
  static const int kGatewayFieldNumber = 1;
  inline const ::nway_fs_opterator::nway_gateway& gateway() const;
  inline ::nway_fs_opterator::nway_gateway* mutable_gateway();
  inline ::nway_fs_opterator::nway_gateway* release_gateway();
  inline void set_allocated_gateway(::nway_fs_opterator::nway_gateway* gateway);

  // @@protoc_insertion_point(class_scope:nway_fs_opterator.erase_nway_gateway_req)
 private:
  inline void set_has_gateway();
  inline void clear_has_gateway();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::nway_fs_opterator::nway_gateway* gateway_;
  friend void  protobuf_AddDesc_gateway_5fop_2eproto();
  friend void protobuf_AssignDesc_gateway_5fop_2eproto();
  friend void protobuf_ShutdownFile_gateway_5fop_2eproto();

  void InitAsDefaultInstance();
  static erase_nway_gateway_req* default_instance_;
};
// -------------------------------------------------------------------

class erase_nway_gateway_rsp : public ::google::protobuf::Message {
 public:
  erase_nway_gateway_rsp();
  virtual ~erase_nway_gateway_rsp();

  erase_nway_gateway_rsp(const erase_nway_gateway_rsp& from);

  inline erase_nway_gateway_rsp& operator=(const erase_nway_gateway_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const erase_nway_gateway_rsp& default_instance();

  void Swap(erase_nway_gateway_rsp* other);

  // implements Message ----------------------------------------------

  erase_nway_gateway_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const erase_nway_gateway_rsp& from);
  void MergeFrom(const erase_nway_gateway_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string gateway_name = 1;
  inline bool has_gateway_name() const;
  inline void clear_gateway_name();
  static const int kGatewayNameFieldNumber = 1;
  inline const ::std::string& gateway_name() const;
  inline void set_gateway_name(const ::std::string& value);
  inline void set_gateway_name(const char* value);
  inline void set_gateway_name(const char* value, size_t size);
  inline ::std::string* mutable_gateway_name();
  inline ::std::string* release_gateway_name();
  inline void set_allocated_gateway_name(::std::string* gateway_name);

  // required .nway_fs_opterator.nway_op_status status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::nway_fs_opterator::nway_op_status status() const;
  inline void set_status(::nway_fs_opterator::nway_op_status value);

  // optional string res_text = 3;
  inline bool has_res_text() const;
  inline void clear_res_text();
  static const int kResTextFieldNumber = 3;
  inline const ::std::string& res_text() const;
  inline void set_res_text(const ::std::string& value);
  inline void set_res_text(const char* value);
  inline void set_res_text(const char* value, size_t size);
  inline ::std::string* mutable_res_text();
  inline ::std::string* release_res_text();
  inline void set_allocated_res_text(::std::string* res_text);

  // @@protoc_insertion_point(class_scope:nway_fs_opterator.erase_nway_gateway_rsp)
 private:
  inline void set_has_gateway_name();
  inline void clear_has_gateway_name();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_res_text();
  inline void clear_has_res_text();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* gateway_name_;
  ::std::string* res_text_;
  int status_;
  friend void  protobuf_AddDesc_gateway_5fop_2eproto();
  friend void protobuf_AssignDesc_gateway_5fop_2eproto();
  friend void protobuf_ShutdownFile_gateway_5fop_2eproto();

  void InitAsDefaultInstance();
  static erase_nway_gateway_rsp* default_instance_;
};
// -------------------------------------------------------------------

class reload_gateway_req : public ::google::protobuf::Message {
 public:
  reload_gateway_req();
  virtual ~reload_gateway_req();

  reload_gateway_req(const reload_gateway_req& from);

  inline reload_gateway_req& operator=(const reload_gateway_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const reload_gateway_req& default_instance();

  void Swap(reload_gateway_req* other);

  // implements Message ----------------------------------------------

  reload_gateway_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const reload_gateway_req& from);
  void MergeFrom(const reload_gateway_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string host = 1;
  inline bool has_host() const;
  inline void clear_host();
  static const int kHostFieldNumber = 1;
  inline const ::std::string& host() const;
  inline void set_host(const ::std::string& value);
  inline void set_host(const char* value);
  inline void set_host(const char* value, size_t size);
  inline ::std::string* mutable_host();
  inline ::std::string* release_host();
  inline void set_allocated_host(::std::string* host);

  // optional string port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline const ::std::string& port() const;
  inline void set_port(const ::std::string& value);
  inline void set_port(const char* value);
  inline void set_port(const char* value, size_t size);
  inline ::std::string* mutable_port();
  inline ::std::string* release_port();
  inline void set_allocated_port(::std::string* port);

  // optional string password = 3;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 3;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:nway_fs_opterator.reload_gateway_req)
 private:
  inline void set_has_host();
  inline void clear_has_host();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* host_;
  ::std::string* port_;
  ::std::string* password_;
  friend void  protobuf_AddDesc_gateway_5fop_2eproto();
  friend void protobuf_AssignDesc_gateway_5fop_2eproto();
  friend void protobuf_ShutdownFile_gateway_5fop_2eproto();

  void InitAsDefaultInstance();
  static reload_gateway_req* default_instance_;
};
// -------------------------------------------------------------------

class reload_gateway_rsp : public ::google::protobuf::Message {
 public:
  reload_gateway_rsp();
  virtual ~reload_gateway_rsp();

  reload_gateway_rsp(const reload_gateway_rsp& from);

  inline reload_gateway_rsp& operator=(const reload_gateway_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const reload_gateway_rsp& default_instance();

  void Swap(reload_gateway_rsp* other);

  // implements Message ----------------------------------------------

  reload_gateway_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const reload_gateway_rsp& from);
  void MergeFrom(const reload_gateway_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .nway_fs_opterator.nway_op_status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::nway_fs_opterator::nway_op_status status() const;
  inline void set_status(::nway_fs_opterator::nway_op_status value);

  // @@protoc_insertion_point(class_scope:nway_fs_opterator.reload_gateway_rsp)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int status_;
  friend void  protobuf_AddDesc_gateway_5fop_2eproto();
  friend void protobuf_AssignDesc_gateway_5fop_2eproto();
  friend void protobuf_ShutdownFile_gateway_5fop_2eproto();

  void InitAsDefaultInstance();
  static reload_gateway_rsp* default_instance_;
};
// ===================================================================


// ===================================================================

// nway_gateway

// required string gateway_name = 1;
inline bool nway_gateway::has_gateway_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void nway_gateway::set_has_gateway_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void nway_gateway::clear_has_gateway_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void nway_gateway::clear_gateway_name() {
  if (gateway_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gateway_name_->clear();
  }
  clear_has_gateway_name();
}
inline const ::std::string& nway_gateway::gateway_name() const {
  // @@protoc_insertion_point(field_get:nway_fs_opterator.nway_gateway.gateway_name)
  return *gateway_name_;
}
inline void nway_gateway::set_gateway_name(const ::std::string& value) {
  set_has_gateway_name();
  if (gateway_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gateway_name_ = new ::std::string;
  }
  gateway_name_->assign(value);
  // @@protoc_insertion_point(field_set:nway_fs_opterator.nway_gateway.gateway_name)
}
inline void nway_gateway::set_gateway_name(const char* value) {
  set_has_gateway_name();
  if (gateway_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gateway_name_ = new ::std::string;
  }
  gateway_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:nway_fs_opterator.nway_gateway.gateway_name)
}
inline void nway_gateway::set_gateway_name(const char* value, size_t size) {
  set_has_gateway_name();
  if (gateway_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gateway_name_ = new ::std::string;
  }
  gateway_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nway_fs_opterator.nway_gateway.gateway_name)
}
inline ::std::string* nway_gateway::mutable_gateway_name() {
  set_has_gateway_name();
  if (gateway_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gateway_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:nway_fs_opterator.nway_gateway.gateway_name)
  return gateway_name_;
}
inline ::std::string* nway_gateway::release_gateway_name() {
  clear_has_gateway_name();
  if (gateway_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = gateway_name_;
    gateway_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void nway_gateway::set_allocated_gateway_name(::std::string* gateway_name) {
  if (gateway_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete gateway_name_;
  }
  if (gateway_name) {
    set_has_gateway_name();
    gateway_name_ = gateway_name;
  } else {
    clear_has_gateway_name();
    gateway_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:nway_fs_opterator.nway_gateway.gateway_name)
}

// optional string username = 2;
inline bool nway_gateway::has_username() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void nway_gateway::set_has_username() {
  _has_bits_[0] |= 0x00000002u;
}
inline void nway_gateway::clear_has_username() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void nway_gateway::clear_username() {
  if (username_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& nway_gateway::username() const {
  // @@protoc_insertion_point(field_get:nway_fs_opterator.nway_gateway.username)
  return *username_;
}
inline void nway_gateway::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    username_ = new ::std::string;
  }
  username_->assign(value);
  // @@protoc_insertion_point(field_set:nway_fs_opterator.nway_gateway.username)
}
inline void nway_gateway::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    username_ = new ::std::string;
  }
  username_->assign(value);
  // @@protoc_insertion_point(field_set_char:nway_fs_opterator.nway_gateway.username)
}
inline void nway_gateway::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nway_fs_opterator.nway_gateway.username)
}
inline ::std::string* nway_gateway::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    username_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:nway_fs_opterator.nway_gateway.username)
  return username_;
}
inline ::std::string* nway_gateway::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void nway_gateway::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:nway_fs_opterator.nway_gateway.username)
}

// optional string realm = 3;
inline bool nway_gateway::has_realm() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void nway_gateway::set_has_realm() {
  _has_bits_[0] |= 0x00000004u;
}
inline void nway_gateway::clear_has_realm() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void nway_gateway::clear_realm() {
  if (realm_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    realm_->clear();
  }
  clear_has_realm();
}
inline const ::std::string& nway_gateway::realm() const {
  // @@protoc_insertion_point(field_get:nway_fs_opterator.nway_gateway.realm)
  return *realm_;
}
inline void nway_gateway::set_realm(const ::std::string& value) {
  set_has_realm();
  if (realm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    realm_ = new ::std::string;
  }
  realm_->assign(value);
  // @@protoc_insertion_point(field_set:nway_fs_opterator.nway_gateway.realm)
}
inline void nway_gateway::set_realm(const char* value) {
  set_has_realm();
  if (realm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    realm_ = new ::std::string;
  }
  realm_->assign(value);
  // @@protoc_insertion_point(field_set_char:nway_fs_opterator.nway_gateway.realm)
}
inline void nway_gateway::set_realm(const char* value, size_t size) {
  set_has_realm();
  if (realm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    realm_ = new ::std::string;
  }
  realm_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nway_fs_opterator.nway_gateway.realm)
}
inline ::std::string* nway_gateway::mutable_realm() {
  set_has_realm();
  if (realm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    realm_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:nway_fs_opterator.nway_gateway.realm)
  return realm_;
}
inline ::std::string* nway_gateway::release_realm() {
  clear_has_realm();
  if (realm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = realm_;
    realm_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void nway_gateway::set_allocated_realm(::std::string* realm) {
  if (realm_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete realm_;
  }
  if (realm) {
    set_has_realm();
    realm_ = realm;
  } else {
    clear_has_realm();
    realm_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:nway_fs_opterator.nway_gateway.realm)
}

// optional string from_user = 4;
inline bool nway_gateway::has_from_user() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void nway_gateway::set_has_from_user() {
  _has_bits_[0] |= 0x00000008u;
}
inline void nway_gateway::clear_has_from_user() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void nway_gateway::clear_from_user() {
  if (from_user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    from_user_->clear();
  }
  clear_has_from_user();
}
inline const ::std::string& nway_gateway::from_user() const {
  // @@protoc_insertion_point(field_get:nway_fs_opterator.nway_gateway.from_user)
  return *from_user_;
}
inline void nway_gateway::set_from_user(const ::std::string& value) {
  set_has_from_user();
  if (from_user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    from_user_ = new ::std::string;
  }
  from_user_->assign(value);
  // @@protoc_insertion_point(field_set:nway_fs_opterator.nway_gateway.from_user)
}
inline void nway_gateway::set_from_user(const char* value) {
  set_has_from_user();
  if (from_user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    from_user_ = new ::std::string;
  }
  from_user_->assign(value);
  // @@protoc_insertion_point(field_set_char:nway_fs_opterator.nway_gateway.from_user)
}
inline void nway_gateway::set_from_user(const char* value, size_t size) {
  set_has_from_user();
  if (from_user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    from_user_ = new ::std::string;
  }
  from_user_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nway_fs_opterator.nway_gateway.from_user)
}
inline ::std::string* nway_gateway::mutable_from_user() {
  set_has_from_user();
  if (from_user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    from_user_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:nway_fs_opterator.nway_gateway.from_user)
  return from_user_;
}
inline ::std::string* nway_gateway::release_from_user() {
  clear_has_from_user();
  if (from_user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = from_user_;
    from_user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void nway_gateway::set_allocated_from_user(::std::string* from_user) {
  if (from_user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete from_user_;
  }
  if (from_user) {
    set_has_from_user();
    from_user_ = from_user;
  } else {
    clear_has_from_user();
    from_user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:nway_fs_opterator.nway_gateway.from_user)
}

// optional string from_domain = 5;
inline bool nway_gateway::has_from_domain() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void nway_gateway::set_has_from_domain() {
  _has_bits_[0] |= 0x00000010u;
}
inline void nway_gateway::clear_has_from_domain() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void nway_gateway::clear_from_domain() {
  if (from_domain_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    from_domain_->clear();
  }
  clear_has_from_domain();
}
inline const ::std::string& nway_gateway::from_domain() const {
  // @@protoc_insertion_point(field_get:nway_fs_opterator.nway_gateway.from_domain)
  return *from_domain_;
}
inline void nway_gateway::set_from_domain(const ::std::string& value) {
  set_has_from_domain();
  if (from_domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    from_domain_ = new ::std::string;
  }
  from_domain_->assign(value);
  // @@protoc_insertion_point(field_set:nway_fs_opterator.nway_gateway.from_domain)
}
inline void nway_gateway::set_from_domain(const char* value) {
  set_has_from_domain();
  if (from_domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    from_domain_ = new ::std::string;
  }
  from_domain_->assign(value);
  // @@protoc_insertion_point(field_set_char:nway_fs_opterator.nway_gateway.from_domain)
}
inline void nway_gateway::set_from_domain(const char* value, size_t size) {
  set_has_from_domain();
  if (from_domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    from_domain_ = new ::std::string;
  }
  from_domain_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nway_fs_opterator.nway_gateway.from_domain)
}
inline ::std::string* nway_gateway::mutable_from_domain() {
  set_has_from_domain();
  if (from_domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    from_domain_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:nway_fs_opterator.nway_gateway.from_domain)
  return from_domain_;
}
inline ::std::string* nway_gateway::release_from_domain() {
  clear_has_from_domain();
  if (from_domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = from_domain_;
    from_domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void nway_gateway::set_allocated_from_domain(::std::string* from_domain) {
  if (from_domain_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete from_domain_;
  }
  if (from_domain) {
    set_has_from_domain();
    from_domain_ = from_domain;
  } else {
    clear_has_from_domain();
    from_domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:nway_fs_opterator.nway_gateway.from_domain)
}

// optional string password = 6;
inline bool nway_gateway::has_password() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void nway_gateway::set_has_password() {
  _has_bits_[0] |= 0x00000020u;
}
inline void nway_gateway::clear_has_password() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void nway_gateway::clear_password() {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& nway_gateway::password() const {
  // @@protoc_insertion_point(field_get:nway_fs_opterator.nway_gateway.password)
  return *password_;
}
inline void nway_gateway::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set:nway_fs_opterator.nway_gateway.password)
}
inline void nway_gateway::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set_char:nway_fs_opterator.nway_gateway.password)
}
inline void nway_gateway::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nway_fs_opterator.nway_gateway.password)
}
inline ::std::string* nway_gateway::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:nway_fs_opterator.nway_gateway.password)
  return password_;
}
inline ::std::string* nway_gateway::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void nway_gateway::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:nway_fs_opterator.nway_gateway.password)
}

// optional string extension = 7;
inline bool nway_gateway::has_extension() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void nway_gateway::set_has_extension() {
  _has_bits_[0] |= 0x00000040u;
}
inline void nway_gateway::clear_has_extension() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void nway_gateway::clear_extension() {
  if (extension_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extension_->clear();
  }
  clear_has_extension();
}
inline const ::std::string& nway_gateway::extension() const {
  // @@protoc_insertion_point(field_get:nway_fs_opterator.nway_gateway.extension)
  return *extension_;
}
inline void nway_gateway::set_extension(const ::std::string& value) {
  set_has_extension();
  if (extension_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extension_ = new ::std::string;
  }
  extension_->assign(value);
  // @@protoc_insertion_point(field_set:nway_fs_opterator.nway_gateway.extension)
}
inline void nway_gateway::set_extension(const char* value) {
  set_has_extension();
  if (extension_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extension_ = new ::std::string;
  }
  extension_->assign(value);
  // @@protoc_insertion_point(field_set_char:nway_fs_opterator.nway_gateway.extension)
}
inline void nway_gateway::set_extension(const char* value, size_t size) {
  set_has_extension();
  if (extension_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extension_ = new ::std::string;
  }
  extension_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nway_fs_opterator.nway_gateway.extension)
}
inline ::std::string* nway_gateway::mutable_extension() {
  set_has_extension();
  if (extension_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extension_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:nway_fs_opterator.nway_gateway.extension)
  return extension_;
}
inline ::std::string* nway_gateway::release_extension() {
  clear_has_extension();
  if (extension_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = extension_;
    extension_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void nway_gateway::set_allocated_extension(::std::string* extension) {
  if (extension_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete extension_;
  }
  if (extension) {
    set_has_extension();
    extension_ = extension;
  } else {
    clear_has_extension();
    extension_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:nway_fs_opterator.nway_gateway.extension)
}

// optional string proxy = 8;
inline bool nway_gateway::has_proxy() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void nway_gateway::set_has_proxy() {
  _has_bits_[0] |= 0x00000080u;
}
inline void nway_gateway::clear_has_proxy() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void nway_gateway::clear_proxy() {
  if (proxy_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    proxy_->clear();
  }
  clear_has_proxy();
}
inline const ::std::string& nway_gateway::proxy() const {
  // @@protoc_insertion_point(field_get:nway_fs_opterator.nway_gateway.proxy)
  return *proxy_;
}
inline void nway_gateway::set_proxy(const ::std::string& value) {
  set_has_proxy();
  if (proxy_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    proxy_ = new ::std::string;
  }
  proxy_->assign(value);
  // @@protoc_insertion_point(field_set:nway_fs_opterator.nway_gateway.proxy)
}
inline void nway_gateway::set_proxy(const char* value) {
  set_has_proxy();
  if (proxy_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    proxy_ = new ::std::string;
  }
  proxy_->assign(value);
  // @@protoc_insertion_point(field_set_char:nway_fs_opterator.nway_gateway.proxy)
}
inline void nway_gateway::set_proxy(const char* value, size_t size) {
  set_has_proxy();
  if (proxy_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    proxy_ = new ::std::string;
  }
  proxy_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nway_fs_opterator.nway_gateway.proxy)
}
inline ::std::string* nway_gateway::mutable_proxy() {
  set_has_proxy();
  if (proxy_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    proxy_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:nway_fs_opterator.nway_gateway.proxy)
  return proxy_;
}
inline ::std::string* nway_gateway::release_proxy() {
  clear_has_proxy();
  if (proxy_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = proxy_;
    proxy_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void nway_gateway::set_allocated_proxy(::std::string* proxy) {
  if (proxy_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete proxy_;
  }
  if (proxy) {
    set_has_proxy();
    proxy_ = proxy;
  } else {
    clear_has_proxy();
    proxy_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:nway_fs_opterator.nway_gateway.proxy)
}

// optional string expire_seconds = 9;
inline bool nway_gateway::has_expire_seconds() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void nway_gateway::set_has_expire_seconds() {
  _has_bits_[0] |= 0x00000100u;
}
inline void nway_gateway::clear_has_expire_seconds() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void nway_gateway::clear_expire_seconds() {
  if (expire_seconds_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    expire_seconds_->clear();
  }
  clear_has_expire_seconds();
}
inline const ::std::string& nway_gateway::expire_seconds() const {
  // @@protoc_insertion_point(field_get:nway_fs_opterator.nway_gateway.expire_seconds)
  return *expire_seconds_;
}
inline void nway_gateway::set_expire_seconds(const ::std::string& value) {
  set_has_expire_seconds();
  if (expire_seconds_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    expire_seconds_ = new ::std::string;
  }
  expire_seconds_->assign(value);
  // @@protoc_insertion_point(field_set:nway_fs_opterator.nway_gateway.expire_seconds)
}
inline void nway_gateway::set_expire_seconds(const char* value) {
  set_has_expire_seconds();
  if (expire_seconds_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    expire_seconds_ = new ::std::string;
  }
  expire_seconds_->assign(value);
  // @@protoc_insertion_point(field_set_char:nway_fs_opterator.nway_gateway.expire_seconds)
}
inline void nway_gateway::set_expire_seconds(const char* value, size_t size) {
  set_has_expire_seconds();
  if (expire_seconds_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    expire_seconds_ = new ::std::string;
  }
  expire_seconds_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nway_fs_opterator.nway_gateway.expire_seconds)
}
inline ::std::string* nway_gateway::mutable_expire_seconds() {
  set_has_expire_seconds();
  if (expire_seconds_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    expire_seconds_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:nway_fs_opterator.nway_gateway.expire_seconds)
  return expire_seconds_;
}
inline ::std::string* nway_gateway::release_expire_seconds() {
  clear_has_expire_seconds();
  if (expire_seconds_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = expire_seconds_;
    expire_seconds_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void nway_gateway::set_allocated_expire_seconds(::std::string* expire_seconds) {
  if (expire_seconds_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete expire_seconds_;
  }
  if (expire_seconds) {
    set_has_expire_seconds();
    expire_seconds_ = expire_seconds;
  } else {
    clear_has_expire_seconds();
    expire_seconds_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:nway_fs_opterator.nway_gateway.expire_seconds)
}

// optional string register = 10;
inline bool nway_gateway::has_register_() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void nway_gateway::set_has_register_() {
  _has_bits_[0] |= 0x00000200u;
}
inline void nway_gateway::clear_has_register_() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void nway_gateway::clear_register_() {
  if (register__ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    register__->clear();
  }
  clear_has_register_();
}
inline const ::std::string& nway_gateway::register_() const {
  // @@protoc_insertion_point(field_get:nway_fs_opterator.nway_gateway.register)
  return *register__;
}
inline void nway_gateway::set_register_(const ::std::string& value) {
  set_has_register_();
  if (register__ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    register__ = new ::std::string;
  }
  register__->assign(value);
  // @@protoc_insertion_point(field_set:nway_fs_opterator.nway_gateway.register)
}
inline void nway_gateway::set_register_(const char* value) {
  set_has_register_();
  if (register__ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    register__ = new ::std::string;
  }
  register__->assign(value);
  // @@protoc_insertion_point(field_set_char:nway_fs_opterator.nway_gateway.register)
}
inline void nway_gateway::set_register_(const char* value, size_t size) {
  set_has_register_();
  if (register__ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    register__ = new ::std::string;
  }
  register__->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nway_fs_opterator.nway_gateway.register)
}
inline ::std::string* nway_gateway::mutable_register_() {
  set_has_register_();
  if (register__ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    register__ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:nway_fs_opterator.nway_gateway.register)
  return register__;
}
inline ::std::string* nway_gateway::release_register_() {
  clear_has_register_();
  if (register__ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = register__;
    register__ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void nway_gateway::set_allocated_register_(::std::string* register_) {
  if (register__ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete register__;
  }
  if (register_) {
    set_has_register_();
    register__ = register_;
  } else {
    clear_has_register_();
    register__ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:nway_fs_opterator.nway_gateway.register)
}

// optional string register_transport = 11;
inline bool nway_gateway::has_register_transport() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void nway_gateway::set_has_register_transport() {
  _has_bits_[0] |= 0x00000400u;
}
inline void nway_gateway::clear_has_register_transport() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void nway_gateway::clear_register_transport() {
  if (register_transport_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    register_transport_->clear();
  }
  clear_has_register_transport();
}
inline const ::std::string& nway_gateway::register_transport() const {
  // @@protoc_insertion_point(field_get:nway_fs_opterator.nway_gateway.register_transport)
  return *register_transport_;
}
inline void nway_gateway::set_register_transport(const ::std::string& value) {
  set_has_register_transport();
  if (register_transport_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    register_transport_ = new ::std::string;
  }
  register_transport_->assign(value);
  // @@protoc_insertion_point(field_set:nway_fs_opterator.nway_gateway.register_transport)
}
inline void nway_gateway::set_register_transport(const char* value) {
  set_has_register_transport();
  if (register_transport_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    register_transport_ = new ::std::string;
  }
  register_transport_->assign(value);
  // @@protoc_insertion_point(field_set_char:nway_fs_opterator.nway_gateway.register_transport)
}
inline void nway_gateway::set_register_transport(const char* value, size_t size) {
  set_has_register_transport();
  if (register_transport_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    register_transport_ = new ::std::string;
  }
  register_transport_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nway_fs_opterator.nway_gateway.register_transport)
}
inline ::std::string* nway_gateway::mutable_register_transport() {
  set_has_register_transport();
  if (register_transport_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    register_transport_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:nway_fs_opterator.nway_gateway.register_transport)
  return register_transport_;
}
inline ::std::string* nway_gateway::release_register_transport() {
  clear_has_register_transport();
  if (register_transport_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = register_transport_;
    register_transport_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void nway_gateway::set_allocated_register_transport(::std::string* register_transport) {
  if (register_transport_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete register_transport_;
  }
  if (register_transport) {
    set_has_register_transport();
    register_transport_ = register_transport;
  } else {
    clear_has_register_transport();
    register_transport_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:nway_fs_opterator.nway_gateway.register_transport)
}

// optional string retry_seconds = 12;
inline bool nway_gateway::has_retry_seconds() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void nway_gateway::set_has_retry_seconds() {
  _has_bits_[0] |= 0x00000800u;
}
inline void nway_gateway::clear_has_retry_seconds() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void nway_gateway::clear_retry_seconds() {
  if (retry_seconds_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    retry_seconds_->clear();
  }
  clear_has_retry_seconds();
}
inline const ::std::string& nway_gateway::retry_seconds() const {
  // @@protoc_insertion_point(field_get:nway_fs_opterator.nway_gateway.retry_seconds)
  return *retry_seconds_;
}
inline void nway_gateway::set_retry_seconds(const ::std::string& value) {
  set_has_retry_seconds();
  if (retry_seconds_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    retry_seconds_ = new ::std::string;
  }
  retry_seconds_->assign(value);
  // @@protoc_insertion_point(field_set:nway_fs_opterator.nway_gateway.retry_seconds)
}
inline void nway_gateway::set_retry_seconds(const char* value) {
  set_has_retry_seconds();
  if (retry_seconds_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    retry_seconds_ = new ::std::string;
  }
  retry_seconds_->assign(value);
  // @@protoc_insertion_point(field_set_char:nway_fs_opterator.nway_gateway.retry_seconds)
}
inline void nway_gateway::set_retry_seconds(const char* value, size_t size) {
  set_has_retry_seconds();
  if (retry_seconds_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    retry_seconds_ = new ::std::string;
  }
  retry_seconds_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nway_fs_opterator.nway_gateway.retry_seconds)
}
inline ::std::string* nway_gateway::mutable_retry_seconds() {
  set_has_retry_seconds();
  if (retry_seconds_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    retry_seconds_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:nway_fs_opterator.nway_gateway.retry_seconds)
  return retry_seconds_;
}
inline ::std::string* nway_gateway::release_retry_seconds() {
  clear_has_retry_seconds();
  if (retry_seconds_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = retry_seconds_;
    retry_seconds_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void nway_gateway::set_allocated_retry_seconds(::std::string* retry_seconds) {
  if (retry_seconds_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete retry_seconds_;
  }
  if (retry_seconds) {
    set_has_retry_seconds();
    retry_seconds_ = retry_seconds;
  } else {
    clear_has_retry_seconds();
    retry_seconds_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:nway_fs_opterator.nway_gateway.retry_seconds)
}

// optional string caller_id_in_from = 13;
inline bool nway_gateway::has_caller_id_in_from() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void nway_gateway::set_has_caller_id_in_from() {
  _has_bits_[0] |= 0x00001000u;
}
inline void nway_gateway::clear_has_caller_id_in_from() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void nway_gateway::clear_caller_id_in_from() {
  if (caller_id_in_from_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    caller_id_in_from_->clear();
  }
  clear_has_caller_id_in_from();
}
inline const ::std::string& nway_gateway::caller_id_in_from() const {
  // @@protoc_insertion_point(field_get:nway_fs_opterator.nway_gateway.caller_id_in_from)
  return *caller_id_in_from_;
}
inline void nway_gateway::set_caller_id_in_from(const ::std::string& value) {
  set_has_caller_id_in_from();
  if (caller_id_in_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    caller_id_in_from_ = new ::std::string;
  }
  caller_id_in_from_->assign(value);
  // @@protoc_insertion_point(field_set:nway_fs_opterator.nway_gateway.caller_id_in_from)
}
inline void nway_gateway::set_caller_id_in_from(const char* value) {
  set_has_caller_id_in_from();
  if (caller_id_in_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    caller_id_in_from_ = new ::std::string;
  }
  caller_id_in_from_->assign(value);
  // @@protoc_insertion_point(field_set_char:nway_fs_opterator.nway_gateway.caller_id_in_from)
}
inline void nway_gateway::set_caller_id_in_from(const char* value, size_t size) {
  set_has_caller_id_in_from();
  if (caller_id_in_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    caller_id_in_from_ = new ::std::string;
  }
  caller_id_in_from_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nway_fs_opterator.nway_gateway.caller_id_in_from)
}
inline ::std::string* nway_gateway::mutable_caller_id_in_from() {
  set_has_caller_id_in_from();
  if (caller_id_in_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    caller_id_in_from_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:nway_fs_opterator.nway_gateway.caller_id_in_from)
  return caller_id_in_from_;
}
inline ::std::string* nway_gateway::release_caller_id_in_from() {
  clear_has_caller_id_in_from();
  if (caller_id_in_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = caller_id_in_from_;
    caller_id_in_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void nway_gateway::set_allocated_caller_id_in_from(::std::string* caller_id_in_from) {
  if (caller_id_in_from_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete caller_id_in_from_;
  }
  if (caller_id_in_from) {
    set_has_caller_id_in_from();
    caller_id_in_from_ = caller_id_in_from;
  } else {
    clear_has_caller_id_in_from();
    caller_id_in_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:nway_fs_opterator.nway_gateway.caller_id_in_from)
}

// optional string contact_params = 14;
inline bool nway_gateway::has_contact_params() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void nway_gateway::set_has_contact_params() {
  _has_bits_[0] |= 0x00002000u;
}
inline void nway_gateway::clear_has_contact_params() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void nway_gateway::clear_contact_params() {
  if (contact_params_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contact_params_->clear();
  }
  clear_has_contact_params();
}
inline const ::std::string& nway_gateway::contact_params() const {
  // @@protoc_insertion_point(field_get:nway_fs_opterator.nway_gateway.contact_params)
  return *contact_params_;
}
inline void nway_gateway::set_contact_params(const ::std::string& value) {
  set_has_contact_params();
  if (contact_params_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contact_params_ = new ::std::string;
  }
  contact_params_->assign(value);
  // @@protoc_insertion_point(field_set:nway_fs_opterator.nway_gateway.contact_params)
}
inline void nway_gateway::set_contact_params(const char* value) {
  set_has_contact_params();
  if (contact_params_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contact_params_ = new ::std::string;
  }
  contact_params_->assign(value);
  // @@protoc_insertion_point(field_set_char:nway_fs_opterator.nway_gateway.contact_params)
}
inline void nway_gateway::set_contact_params(const char* value, size_t size) {
  set_has_contact_params();
  if (contact_params_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contact_params_ = new ::std::string;
  }
  contact_params_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nway_fs_opterator.nway_gateway.contact_params)
}
inline ::std::string* nway_gateway::mutable_contact_params() {
  set_has_contact_params();
  if (contact_params_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contact_params_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:nway_fs_opterator.nway_gateway.contact_params)
  return contact_params_;
}
inline ::std::string* nway_gateway::release_contact_params() {
  clear_has_contact_params();
  if (contact_params_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = contact_params_;
    contact_params_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void nway_gateway::set_allocated_contact_params(::std::string* contact_params) {
  if (contact_params_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete contact_params_;
  }
  if (contact_params) {
    set_has_contact_params();
    contact_params_ = contact_params;
  } else {
    clear_has_contact_params();
    contact_params_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:nway_fs_opterator.nway_gateway.contact_params)
}

// optional string ping = 15;
inline bool nway_gateway::has_ping() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void nway_gateway::set_has_ping() {
  _has_bits_[0] |= 0x00004000u;
}
inline void nway_gateway::clear_has_ping() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void nway_gateway::clear_ping() {
  if (ping_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ping_->clear();
  }
  clear_has_ping();
}
inline const ::std::string& nway_gateway::ping() const {
  // @@protoc_insertion_point(field_get:nway_fs_opterator.nway_gateway.ping)
  return *ping_;
}
inline void nway_gateway::set_ping(const ::std::string& value) {
  set_has_ping();
  if (ping_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ping_ = new ::std::string;
  }
  ping_->assign(value);
  // @@protoc_insertion_point(field_set:nway_fs_opterator.nway_gateway.ping)
}
inline void nway_gateway::set_ping(const char* value) {
  set_has_ping();
  if (ping_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ping_ = new ::std::string;
  }
  ping_->assign(value);
  // @@protoc_insertion_point(field_set_char:nway_fs_opterator.nway_gateway.ping)
}
inline void nway_gateway::set_ping(const char* value, size_t size) {
  set_has_ping();
  if (ping_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ping_ = new ::std::string;
  }
  ping_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nway_fs_opterator.nway_gateway.ping)
}
inline ::std::string* nway_gateway::mutable_ping() {
  set_has_ping();
  if (ping_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ping_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:nway_fs_opterator.nway_gateway.ping)
  return ping_;
}
inline ::std::string* nway_gateway::release_ping() {
  clear_has_ping();
  if (ping_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ping_;
    ping_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void nway_gateway::set_allocated_ping(::std::string* ping) {
  if (ping_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ping_;
  }
  if (ping) {
    set_has_ping();
    ping_ = ping;
  } else {
    clear_has_ping();
    ping_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:nway_fs_opterator.nway_gateway.ping)
}

// optional string filename = 16;
inline bool nway_gateway::has_filename() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void nway_gateway::set_has_filename() {
  _has_bits_[0] |= 0x00008000u;
}
inline void nway_gateway::clear_has_filename() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void nway_gateway::clear_filename() {
  if (filename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& nway_gateway::filename() const {
  // @@protoc_insertion_point(field_get:nway_fs_opterator.nway_gateway.filename)
  return *filename_;
}
inline void nway_gateway::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
  // @@protoc_insertion_point(field_set:nway_fs_opterator.nway_gateway.filename)
}
inline void nway_gateway::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
  // @@protoc_insertion_point(field_set_char:nway_fs_opterator.nway_gateway.filename)
}
inline void nway_gateway::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nway_fs_opterator.nway_gateway.filename)
}
inline ::std::string* nway_gateway::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:nway_fs_opterator.nway_gateway.filename)
  return filename_;
}
inline ::std::string* nway_gateway::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void nway_gateway::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:nway_fs_opterator.nway_gateway.filename)
}

// optional string register_proxy = 17;
inline bool nway_gateway::has_register_proxy() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void nway_gateway::set_has_register_proxy() {
  _has_bits_[0] |= 0x00010000u;
}
inline void nway_gateway::clear_has_register_proxy() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void nway_gateway::clear_register_proxy() {
  if (register_proxy_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    register_proxy_->clear();
  }
  clear_has_register_proxy();
}
inline const ::std::string& nway_gateway::register_proxy() const {
  // @@protoc_insertion_point(field_get:nway_fs_opterator.nway_gateway.register_proxy)
  return *register_proxy_;
}
inline void nway_gateway::set_register_proxy(const ::std::string& value) {
  set_has_register_proxy();
  if (register_proxy_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    register_proxy_ = new ::std::string;
  }
  register_proxy_->assign(value);
  // @@protoc_insertion_point(field_set:nway_fs_opterator.nway_gateway.register_proxy)
}
inline void nway_gateway::set_register_proxy(const char* value) {
  set_has_register_proxy();
  if (register_proxy_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    register_proxy_ = new ::std::string;
  }
  register_proxy_->assign(value);
  // @@protoc_insertion_point(field_set_char:nway_fs_opterator.nway_gateway.register_proxy)
}
inline void nway_gateway::set_register_proxy(const char* value, size_t size) {
  set_has_register_proxy();
  if (register_proxy_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    register_proxy_ = new ::std::string;
  }
  register_proxy_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nway_fs_opterator.nway_gateway.register_proxy)
}
inline ::std::string* nway_gateway::mutable_register_proxy() {
  set_has_register_proxy();
  if (register_proxy_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    register_proxy_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:nway_fs_opterator.nway_gateway.register_proxy)
  return register_proxy_;
}
inline ::std::string* nway_gateway::release_register_proxy() {
  clear_has_register_proxy();
  if (register_proxy_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = register_proxy_;
    register_proxy_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void nway_gateway::set_allocated_register_proxy(::std::string* register_proxy) {
  if (register_proxy_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete register_proxy_;
  }
  if (register_proxy) {
    set_has_register_proxy();
    register_proxy_ = register_proxy;
  } else {
    clear_has_register_proxy();
    register_proxy_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:nway_fs_opterator.nway_gateway.register_proxy)
}

// -------------------------------------------------------------------

// get_nway_gateways_req

// required string falg = 1;
inline bool get_nway_gateways_req::has_falg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void get_nway_gateways_req::set_has_falg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void get_nway_gateways_req::clear_has_falg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void get_nway_gateways_req::clear_falg() {
  if (falg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    falg_->clear();
  }
  clear_has_falg();
}
inline const ::std::string& get_nway_gateways_req::falg() const {
  // @@protoc_insertion_point(field_get:nway_fs_opterator.get_nway_gateways_req.falg)
  return *falg_;
}
inline void get_nway_gateways_req::set_falg(const ::std::string& value) {
  set_has_falg();
  if (falg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    falg_ = new ::std::string;
  }
  falg_->assign(value);
  // @@protoc_insertion_point(field_set:nway_fs_opterator.get_nway_gateways_req.falg)
}
inline void get_nway_gateways_req::set_falg(const char* value) {
  set_has_falg();
  if (falg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    falg_ = new ::std::string;
  }
  falg_->assign(value);
  // @@protoc_insertion_point(field_set_char:nway_fs_opterator.get_nway_gateways_req.falg)
}
inline void get_nway_gateways_req::set_falg(const char* value, size_t size) {
  set_has_falg();
  if (falg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    falg_ = new ::std::string;
  }
  falg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nway_fs_opterator.get_nway_gateways_req.falg)
}
inline ::std::string* get_nway_gateways_req::mutable_falg() {
  set_has_falg();
  if (falg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    falg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:nway_fs_opterator.get_nway_gateways_req.falg)
  return falg_;
}
inline ::std::string* get_nway_gateways_req::release_falg() {
  clear_has_falg();
  if (falg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = falg_;
    falg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void get_nway_gateways_req::set_allocated_falg(::std::string* falg) {
  if (falg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete falg_;
  }
  if (falg) {
    set_has_falg();
    falg_ = falg;
  } else {
    clear_has_falg();
    falg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:nway_fs_opterator.get_nway_gateways_req.falg)
}

// required int32 start_pos = 2;
inline bool get_nway_gateways_req::has_start_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void get_nway_gateways_req::set_has_start_pos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void get_nway_gateways_req::clear_has_start_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void get_nway_gateways_req::clear_start_pos() {
  start_pos_ = 0;
  clear_has_start_pos();
}
inline ::google::protobuf::int32 get_nway_gateways_req::start_pos() const {
  // @@protoc_insertion_point(field_get:nway_fs_opterator.get_nway_gateways_req.start_pos)
  return start_pos_;
}
inline void get_nway_gateways_req::set_start_pos(::google::protobuf::int32 value) {
  set_has_start_pos();
  start_pos_ = value;
  // @@protoc_insertion_point(field_set:nway_fs_opterator.get_nway_gateways_req.start_pos)
}

// required int32 number_per_page = 3;
inline bool get_nway_gateways_req::has_number_per_page() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void get_nway_gateways_req::set_has_number_per_page() {
  _has_bits_[0] |= 0x00000004u;
}
inline void get_nway_gateways_req::clear_has_number_per_page() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void get_nway_gateways_req::clear_number_per_page() {
  number_per_page_ = 0;
  clear_has_number_per_page();
}
inline ::google::protobuf::int32 get_nway_gateways_req::number_per_page() const {
  // @@protoc_insertion_point(field_get:nway_fs_opterator.get_nway_gateways_req.number_per_page)
  return number_per_page_;
}
inline void get_nway_gateways_req::set_number_per_page(::google::protobuf::int32 value) {
  set_has_number_per_page();
  number_per_page_ = value;
  // @@protoc_insertion_point(field_set:nway_fs_opterator.get_nway_gateways_req.number_per_page)
}

// -------------------------------------------------------------------

// get_nway_gateways_rsp

// required .nway_fs_opterator.nway_op_status status = 1;
inline bool get_nway_gateways_rsp::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void get_nway_gateways_rsp::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void get_nway_gateways_rsp::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void get_nway_gateways_rsp::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::nway_fs_opterator::nway_op_status get_nway_gateways_rsp::status() const {
  // @@protoc_insertion_point(field_get:nway_fs_opterator.get_nway_gateways_rsp.status)
  return static_cast< ::nway_fs_opterator::nway_op_status >(status_);
}
inline void get_nway_gateways_rsp::set_status(::nway_fs_opterator::nway_op_status value) {
  assert(::nway_fs_opterator::nway_op_status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:nway_fs_opterator.get_nway_gateways_rsp.status)
}

// repeated .nway_fs_opterator.nway_gateway gateways = 2;
inline int get_nway_gateways_rsp::gateways_size() const {
  return gateways_.size();
}
inline void get_nway_gateways_rsp::clear_gateways() {
  gateways_.Clear();
}
inline const ::nway_fs_opterator::nway_gateway& get_nway_gateways_rsp::gateways(int index) const {
  // @@protoc_insertion_point(field_get:nway_fs_opterator.get_nway_gateways_rsp.gateways)
  return gateways_.Get(index);
}
inline ::nway_fs_opterator::nway_gateway* get_nway_gateways_rsp::mutable_gateways(int index) {
  // @@protoc_insertion_point(field_mutable:nway_fs_opterator.get_nway_gateways_rsp.gateways)
  return gateways_.Mutable(index);
}
inline ::nway_fs_opterator::nway_gateway* get_nway_gateways_rsp::add_gateways() {
  // @@protoc_insertion_point(field_add:nway_fs_opterator.get_nway_gateways_rsp.gateways)
  return gateways_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nway_fs_opterator::nway_gateway >&
get_nway_gateways_rsp::gateways() const {
  // @@protoc_insertion_point(field_list:nway_fs_opterator.get_nway_gateways_rsp.gateways)
  return gateways_;
}
inline ::google::protobuf::RepeatedPtrField< ::nway_fs_opterator::nway_gateway >*
get_nway_gateways_rsp::mutable_gateways() {
  // @@protoc_insertion_point(field_mutable_list:nway_fs_opterator.get_nway_gateways_rsp.gateways)
  return &gateways_;
}

// -------------------------------------------------------------------

// add_nway_gateway_req

// required .nway_fs_opterator.nway_gateway gateway = 1;
inline bool add_nway_gateway_req::has_gateway() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void add_nway_gateway_req::set_has_gateway() {
  _has_bits_[0] |= 0x00000001u;
}
inline void add_nway_gateway_req::clear_has_gateway() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void add_nway_gateway_req::clear_gateway() {
  if (gateway_ != NULL) gateway_->::nway_fs_opterator::nway_gateway::Clear();
  clear_has_gateway();
}
inline const ::nway_fs_opterator::nway_gateway& add_nway_gateway_req::gateway() const {
  // @@protoc_insertion_point(field_get:nway_fs_opterator.add_nway_gateway_req.gateway)
  return gateway_ != NULL ? *gateway_ : *default_instance_->gateway_;
}
inline ::nway_fs_opterator::nway_gateway* add_nway_gateway_req::mutable_gateway() {
  set_has_gateway();
  if (gateway_ == NULL) gateway_ = new ::nway_fs_opterator::nway_gateway;
  // @@protoc_insertion_point(field_mutable:nway_fs_opterator.add_nway_gateway_req.gateway)
  return gateway_;
}
inline ::nway_fs_opterator::nway_gateway* add_nway_gateway_req::release_gateway() {
  clear_has_gateway();
  ::nway_fs_opterator::nway_gateway* temp = gateway_;
  gateway_ = NULL;
  return temp;
}
inline void add_nway_gateway_req::set_allocated_gateway(::nway_fs_opterator::nway_gateway* gateway) {
  delete gateway_;
  gateway_ = gateway;
  if (gateway) {
    set_has_gateway();
  } else {
    clear_has_gateway();
  }
  // @@protoc_insertion_point(field_set_allocated:nway_fs_opterator.add_nway_gateway_req.gateway)
}

// -------------------------------------------------------------------

// add_nway_gateway_rsp

// required string gateway_name = 1;
inline bool add_nway_gateway_rsp::has_gateway_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void add_nway_gateway_rsp::set_has_gateway_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void add_nway_gateway_rsp::clear_has_gateway_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void add_nway_gateway_rsp::clear_gateway_name() {
  if (gateway_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gateway_name_->clear();
  }
  clear_has_gateway_name();
}
inline const ::std::string& add_nway_gateway_rsp::gateway_name() const {
  // @@protoc_insertion_point(field_get:nway_fs_opterator.add_nway_gateway_rsp.gateway_name)
  return *gateway_name_;
}
inline void add_nway_gateway_rsp::set_gateway_name(const ::std::string& value) {
  set_has_gateway_name();
  if (gateway_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gateway_name_ = new ::std::string;
  }
  gateway_name_->assign(value);
  // @@protoc_insertion_point(field_set:nway_fs_opterator.add_nway_gateway_rsp.gateway_name)
}
inline void add_nway_gateway_rsp::set_gateway_name(const char* value) {
  set_has_gateway_name();
  if (gateway_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gateway_name_ = new ::std::string;
  }
  gateway_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:nway_fs_opterator.add_nway_gateway_rsp.gateway_name)
}
inline void add_nway_gateway_rsp::set_gateway_name(const char* value, size_t size) {
  set_has_gateway_name();
  if (gateway_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gateway_name_ = new ::std::string;
  }
  gateway_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nway_fs_opterator.add_nway_gateway_rsp.gateway_name)
}
inline ::std::string* add_nway_gateway_rsp::mutable_gateway_name() {
  set_has_gateway_name();
  if (gateway_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gateway_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:nway_fs_opterator.add_nway_gateway_rsp.gateway_name)
  return gateway_name_;
}
inline ::std::string* add_nway_gateway_rsp::release_gateway_name() {
  clear_has_gateway_name();
  if (gateway_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = gateway_name_;
    gateway_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void add_nway_gateway_rsp::set_allocated_gateway_name(::std::string* gateway_name) {
  if (gateway_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete gateway_name_;
  }
  if (gateway_name) {
    set_has_gateway_name();
    gateway_name_ = gateway_name;
  } else {
    clear_has_gateway_name();
    gateway_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:nway_fs_opterator.add_nway_gateway_rsp.gateway_name)
}

// required .nway_fs_opterator.nway_op_status status = 2;
inline bool add_nway_gateway_rsp::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void add_nway_gateway_rsp::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void add_nway_gateway_rsp::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void add_nway_gateway_rsp::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::nway_fs_opterator::nway_op_status add_nway_gateway_rsp::status() const {
  // @@protoc_insertion_point(field_get:nway_fs_opterator.add_nway_gateway_rsp.status)
  return static_cast< ::nway_fs_opterator::nway_op_status >(status_);
}
inline void add_nway_gateway_rsp::set_status(::nway_fs_opterator::nway_op_status value) {
  assert(::nway_fs_opterator::nway_op_status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:nway_fs_opterator.add_nway_gateway_rsp.status)
}

// optional string res_text = 3;
inline bool add_nway_gateway_rsp::has_res_text() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void add_nway_gateway_rsp::set_has_res_text() {
  _has_bits_[0] |= 0x00000004u;
}
inline void add_nway_gateway_rsp::clear_has_res_text() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void add_nway_gateway_rsp::clear_res_text() {
  if (res_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    res_text_->clear();
  }
  clear_has_res_text();
}
inline const ::std::string& add_nway_gateway_rsp::res_text() const {
  // @@protoc_insertion_point(field_get:nway_fs_opterator.add_nway_gateway_rsp.res_text)
  return *res_text_;
}
inline void add_nway_gateway_rsp::set_res_text(const ::std::string& value) {
  set_has_res_text();
  if (res_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    res_text_ = new ::std::string;
  }
  res_text_->assign(value);
  // @@protoc_insertion_point(field_set:nway_fs_opterator.add_nway_gateway_rsp.res_text)
}
inline void add_nway_gateway_rsp::set_res_text(const char* value) {
  set_has_res_text();
  if (res_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    res_text_ = new ::std::string;
  }
  res_text_->assign(value);
  // @@protoc_insertion_point(field_set_char:nway_fs_opterator.add_nway_gateway_rsp.res_text)
}
inline void add_nway_gateway_rsp::set_res_text(const char* value, size_t size) {
  set_has_res_text();
  if (res_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    res_text_ = new ::std::string;
  }
  res_text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nway_fs_opterator.add_nway_gateway_rsp.res_text)
}
inline ::std::string* add_nway_gateway_rsp::mutable_res_text() {
  set_has_res_text();
  if (res_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    res_text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:nway_fs_opterator.add_nway_gateway_rsp.res_text)
  return res_text_;
}
inline ::std::string* add_nway_gateway_rsp::release_res_text() {
  clear_has_res_text();
  if (res_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = res_text_;
    res_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void add_nway_gateway_rsp::set_allocated_res_text(::std::string* res_text) {
  if (res_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete res_text_;
  }
  if (res_text) {
    set_has_res_text();
    res_text_ = res_text;
  } else {
    clear_has_res_text();
    res_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:nway_fs_opterator.add_nway_gateway_rsp.res_text)
}

// -------------------------------------------------------------------

// edit_nway_gateway_req

// required .nway_fs_opterator.nway_gateway gateway = 1;
inline bool edit_nway_gateway_req::has_gateway() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void edit_nway_gateway_req::set_has_gateway() {
  _has_bits_[0] |= 0x00000001u;
}
inline void edit_nway_gateway_req::clear_has_gateway() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void edit_nway_gateway_req::clear_gateway() {
  if (gateway_ != NULL) gateway_->::nway_fs_opterator::nway_gateway::Clear();
  clear_has_gateway();
}
inline const ::nway_fs_opterator::nway_gateway& edit_nway_gateway_req::gateway() const {
  // @@protoc_insertion_point(field_get:nway_fs_opterator.edit_nway_gateway_req.gateway)
  return gateway_ != NULL ? *gateway_ : *default_instance_->gateway_;
}
inline ::nway_fs_opterator::nway_gateway* edit_nway_gateway_req::mutable_gateway() {
  set_has_gateway();
  if (gateway_ == NULL) gateway_ = new ::nway_fs_opterator::nway_gateway;
  // @@protoc_insertion_point(field_mutable:nway_fs_opterator.edit_nway_gateway_req.gateway)
  return gateway_;
}
inline ::nway_fs_opterator::nway_gateway* edit_nway_gateway_req::release_gateway() {
  clear_has_gateway();
  ::nway_fs_opterator::nway_gateway* temp = gateway_;
  gateway_ = NULL;
  return temp;
}
inline void edit_nway_gateway_req::set_allocated_gateway(::nway_fs_opterator::nway_gateway* gateway) {
  delete gateway_;
  gateway_ = gateway;
  if (gateway) {
    set_has_gateway();
  } else {
    clear_has_gateway();
  }
  // @@protoc_insertion_point(field_set_allocated:nway_fs_opterator.edit_nway_gateway_req.gateway)
}

// -------------------------------------------------------------------

// edit_nway_gateway_rsp

// required string gateway_name = 1;
inline bool edit_nway_gateway_rsp::has_gateway_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void edit_nway_gateway_rsp::set_has_gateway_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void edit_nway_gateway_rsp::clear_has_gateway_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void edit_nway_gateway_rsp::clear_gateway_name() {
  if (gateway_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gateway_name_->clear();
  }
  clear_has_gateway_name();
}
inline const ::std::string& edit_nway_gateway_rsp::gateway_name() const {
  // @@protoc_insertion_point(field_get:nway_fs_opterator.edit_nway_gateway_rsp.gateway_name)
  return *gateway_name_;
}
inline void edit_nway_gateway_rsp::set_gateway_name(const ::std::string& value) {
  set_has_gateway_name();
  if (gateway_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gateway_name_ = new ::std::string;
  }
  gateway_name_->assign(value);
  // @@protoc_insertion_point(field_set:nway_fs_opterator.edit_nway_gateway_rsp.gateway_name)
}
inline void edit_nway_gateway_rsp::set_gateway_name(const char* value) {
  set_has_gateway_name();
  if (gateway_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gateway_name_ = new ::std::string;
  }
  gateway_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:nway_fs_opterator.edit_nway_gateway_rsp.gateway_name)
}
inline void edit_nway_gateway_rsp::set_gateway_name(const char* value, size_t size) {
  set_has_gateway_name();
  if (gateway_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gateway_name_ = new ::std::string;
  }
  gateway_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nway_fs_opterator.edit_nway_gateway_rsp.gateway_name)
}
inline ::std::string* edit_nway_gateway_rsp::mutable_gateway_name() {
  set_has_gateway_name();
  if (gateway_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gateway_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:nway_fs_opterator.edit_nway_gateway_rsp.gateway_name)
  return gateway_name_;
}
inline ::std::string* edit_nway_gateway_rsp::release_gateway_name() {
  clear_has_gateway_name();
  if (gateway_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = gateway_name_;
    gateway_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void edit_nway_gateway_rsp::set_allocated_gateway_name(::std::string* gateway_name) {
  if (gateway_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete gateway_name_;
  }
  if (gateway_name) {
    set_has_gateway_name();
    gateway_name_ = gateway_name;
  } else {
    clear_has_gateway_name();
    gateway_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:nway_fs_opterator.edit_nway_gateway_rsp.gateway_name)
}

// required .nway_fs_opterator.nway_op_status status = 2;
inline bool edit_nway_gateway_rsp::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void edit_nway_gateway_rsp::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void edit_nway_gateway_rsp::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void edit_nway_gateway_rsp::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::nway_fs_opterator::nway_op_status edit_nway_gateway_rsp::status() const {
  // @@protoc_insertion_point(field_get:nway_fs_opterator.edit_nway_gateway_rsp.status)
  return static_cast< ::nway_fs_opterator::nway_op_status >(status_);
}
inline void edit_nway_gateway_rsp::set_status(::nway_fs_opterator::nway_op_status value) {
  assert(::nway_fs_opterator::nway_op_status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:nway_fs_opterator.edit_nway_gateway_rsp.status)
}

// optional string res_text = 3;
inline bool edit_nway_gateway_rsp::has_res_text() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void edit_nway_gateway_rsp::set_has_res_text() {
  _has_bits_[0] |= 0x00000004u;
}
inline void edit_nway_gateway_rsp::clear_has_res_text() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void edit_nway_gateway_rsp::clear_res_text() {
  if (res_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    res_text_->clear();
  }
  clear_has_res_text();
}
inline const ::std::string& edit_nway_gateway_rsp::res_text() const {
  // @@protoc_insertion_point(field_get:nway_fs_opterator.edit_nway_gateway_rsp.res_text)
  return *res_text_;
}
inline void edit_nway_gateway_rsp::set_res_text(const ::std::string& value) {
  set_has_res_text();
  if (res_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    res_text_ = new ::std::string;
  }
  res_text_->assign(value);
  // @@protoc_insertion_point(field_set:nway_fs_opterator.edit_nway_gateway_rsp.res_text)
}
inline void edit_nway_gateway_rsp::set_res_text(const char* value) {
  set_has_res_text();
  if (res_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    res_text_ = new ::std::string;
  }
  res_text_->assign(value);
  // @@protoc_insertion_point(field_set_char:nway_fs_opterator.edit_nway_gateway_rsp.res_text)
}
inline void edit_nway_gateway_rsp::set_res_text(const char* value, size_t size) {
  set_has_res_text();
  if (res_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    res_text_ = new ::std::string;
  }
  res_text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nway_fs_opterator.edit_nway_gateway_rsp.res_text)
}
inline ::std::string* edit_nway_gateway_rsp::mutable_res_text() {
  set_has_res_text();
  if (res_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    res_text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:nway_fs_opterator.edit_nway_gateway_rsp.res_text)
  return res_text_;
}
inline ::std::string* edit_nway_gateway_rsp::release_res_text() {
  clear_has_res_text();
  if (res_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = res_text_;
    res_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void edit_nway_gateway_rsp::set_allocated_res_text(::std::string* res_text) {
  if (res_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete res_text_;
  }
  if (res_text) {
    set_has_res_text();
    res_text_ = res_text;
  } else {
    clear_has_res_text();
    res_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:nway_fs_opterator.edit_nway_gateway_rsp.res_text)
}

// -------------------------------------------------------------------

// erase_nway_gateway_req

// required .nway_fs_opterator.nway_gateway gateway = 1;
inline bool erase_nway_gateway_req::has_gateway() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void erase_nway_gateway_req::set_has_gateway() {
  _has_bits_[0] |= 0x00000001u;
}
inline void erase_nway_gateway_req::clear_has_gateway() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void erase_nway_gateway_req::clear_gateway() {
  if (gateway_ != NULL) gateway_->::nway_fs_opterator::nway_gateway::Clear();
  clear_has_gateway();
}
inline const ::nway_fs_opterator::nway_gateway& erase_nway_gateway_req::gateway() const {
  // @@protoc_insertion_point(field_get:nway_fs_opterator.erase_nway_gateway_req.gateway)
  return gateway_ != NULL ? *gateway_ : *default_instance_->gateway_;
}
inline ::nway_fs_opterator::nway_gateway* erase_nway_gateway_req::mutable_gateway() {
  set_has_gateway();
  if (gateway_ == NULL) gateway_ = new ::nway_fs_opterator::nway_gateway;
  // @@protoc_insertion_point(field_mutable:nway_fs_opterator.erase_nway_gateway_req.gateway)
  return gateway_;
}
inline ::nway_fs_opterator::nway_gateway* erase_nway_gateway_req::release_gateway() {
  clear_has_gateway();
  ::nway_fs_opterator::nway_gateway* temp = gateway_;
  gateway_ = NULL;
  return temp;
}
inline void erase_nway_gateway_req::set_allocated_gateway(::nway_fs_opterator::nway_gateway* gateway) {
  delete gateway_;
  gateway_ = gateway;
  if (gateway) {
    set_has_gateway();
  } else {
    clear_has_gateway();
  }
  // @@protoc_insertion_point(field_set_allocated:nway_fs_opterator.erase_nway_gateway_req.gateway)
}

// -------------------------------------------------------------------

// erase_nway_gateway_rsp

// required string gateway_name = 1;
inline bool erase_nway_gateway_rsp::has_gateway_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void erase_nway_gateway_rsp::set_has_gateway_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void erase_nway_gateway_rsp::clear_has_gateway_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void erase_nway_gateway_rsp::clear_gateway_name() {
  if (gateway_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gateway_name_->clear();
  }
  clear_has_gateway_name();
}
inline const ::std::string& erase_nway_gateway_rsp::gateway_name() const {
  // @@protoc_insertion_point(field_get:nway_fs_opterator.erase_nway_gateway_rsp.gateway_name)
  return *gateway_name_;
}
inline void erase_nway_gateway_rsp::set_gateway_name(const ::std::string& value) {
  set_has_gateway_name();
  if (gateway_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gateway_name_ = new ::std::string;
  }
  gateway_name_->assign(value);
  // @@protoc_insertion_point(field_set:nway_fs_opterator.erase_nway_gateway_rsp.gateway_name)
}
inline void erase_nway_gateway_rsp::set_gateway_name(const char* value) {
  set_has_gateway_name();
  if (gateway_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gateway_name_ = new ::std::string;
  }
  gateway_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:nway_fs_opterator.erase_nway_gateway_rsp.gateway_name)
}
inline void erase_nway_gateway_rsp::set_gateway_name(const char* value, size_t size) {
  set_has_gateway_name();
  if (gateway_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gateway_name_ = new ::std::string;
  }
  gateway_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nway_fs_opterator.erase_nway_gateway_rsp.gateway_name)
}
inline ::std::string* erase_nway_gateway_rsp::mutable_gateway_name() {
  set_has_gateway_name();
  if (gateway_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gateway_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:nway_fs_opterator.erase_nway_gateway_rsp.gateway_name)
  return gateway_name_;
}
inline ::std::string* erase_nway_gateway_rsp::release_gateway_name() {
  clear_has_gateway_name();
  if (gateway_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = gateway_name_;
    gateway_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void erase_nway_gateway_rsp::set_allocated_gateway_name(::std::string* gateway_name) {
  if (gateway_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete gateway_name_;
  }
  if (gateway_name) {
    set_has_gateway_name();
    gateway_name_ = gateway_name;
  } else {
    clear_has_gateway_name();
    gateway_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:nway_fs_opterator.erase_nway_gateway_rsp.gateway_name)
}

// required .nway_fs_opterator.nway_op_status status = 2;
inline bool erase_nway_gateway_rsp::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void erase_nway_gateway_rsp::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void erase_nway_gateway_rsp::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void erase_nway_gateway_rsp::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::nway_fs_opterator::nway_op_status erase_nway_gateway_rsp::status() const {
  // @@protoc_insertion_point(field_get:nway_fs_opterator.erase_nway_gateway_rsp.status)
  return static_cast< ::nway_fs_opterator::nway_op_status >(status_);
}
inline void erase_nway_gateway_rsp::set_status(::nway_fs_opterator::nway_op_status value) {
  assert(::nway_fs_opterator::nway_op_status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:nway_fs_opterator.erase_nway_gateway_rsp.status)
}

// optional string res_text = 3;
inline bool erase_nway_gateway_rsp::has_res_text() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void erase_nway_gateway_rsp::set_has_res_text() {
  _has_bits_[0] |= 0x00000004u;
}
inline void erase_nway_gateway_rsp::clear_has_res_text() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void erase_nway_gateway_rsp::clear_res_text() {
  if (res_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    res_text_->clear();
  }
  clear_has_res_text();
}
inline const ::std::string& erase_nway_gateway_rsp::res_text() const {
  // @@protoc_insertion_point(field_get:nway_fs_opterator.erase_nway_gateway_rsp.res_text)
  return *res_text_;
}
inline void erase_nway_gateway_rsp::set_res_text(const ::std::string& value) {
  set_has_res_text();
  if (res_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    res_text_ = new ::std::string;
  }
  res_text_->assign(value);
  // @@protoc_insertion_point(field_set:nway_fs_opterator.erase_nway_gateway_rsp.res_text)
}
inline void erase_nway_gateway_rsp::set_res_text(const char* value) {
  set_has_res_text();
  if (res_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    res_text_ = new ::std::string;
  }
  res_text_->assign(value);
  // @@protoc_insertion_point(field_set_char:nway_fs_opterator.erase_nway_gateway_rsp.res_text)
}
inline void erase_nway_gateway_rsp::set_res_text(const char* value, size_t size) {
  set_has_res_text();
  if (res_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    res_text_ = new ::std::string;
  }
  res_text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nway_fs_opterator.erase_nway_gateway_rsp.res_text)
}
inline ::std::string* erase_nway_gateway_rsp::mutable_res_text() {
  set_has_res_text();
  if (res_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    res_text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:nway_fs_opterator.erase_nway_gateway_rsp.res_text)
  return res_text_;
}
inline ::std::string* erase_nway_gateway_rsp::release_res_text() {
  clear_has_res_text();
  if (res_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = res_text_;
    res_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void erase_nway_gateway_rsp::set_allocated_res_text(::std::string* res_text) {
  if (res_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete res_text_;
  }
  if (res_text) {
    set_has_res_text();
    res_text_ = res_text;
  } else {
    clear_has_res_text();
    res_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:nway_fs_opterator.erase_nway_gateway_rsp.res_text)
}

// -------------------------------------------------------------------

// reload_gateway_req

// optional string host = 1;
inline bool reload_gateway_req::has_host() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void reload_gateway_req::set_has_host() {
  _has_bits_[0] |= 0x00000001u;
}
inline void reload_gateway_req::clear_has_host() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void reload_gateway_req::clear_host() {
  if (host_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    host_->clear();
  }
  clear_has_host();
}
inline const ::std::string& reload_gateway_req::host() const {
  // @@protoc_insertion_point(field_get:nway_fs_opterator.reload_gateway_req.host)
  return *host_;
}
inline void reload_gateway_req::set_host(const ::std::string& value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    host_ = new ::std::string;
  }
  host_->assign(value);
  // @@protoc_insertion_point(field_set:nway_fs_opterator.reload_gateway_req.host)
}
inline void reload_gateway_req::set_host(const char* value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    host_ = new ::std::string;
  }
  host_->assign(value);
  // @@protoc_insertion_point(field_set_char:nway_fs_opterator.reload_gateway_req.host)
}
inline void reload_gateway_req::set_host(const char* value, size_t size) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    host_ = new ::std::string;
  }
  host_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nway_fs_opterator.reload_gateway_req.host)
}
inline ::std::string* reload_gateway_req::mutable_host() {
  set_has_host();
  if (host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    host_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:nway_fs_opterator.reload_gateway_req.host)
  return host_;
}
inline ::std::string* reload_gateway_req::release_host() {
  clear_has_host();
  if (host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = host_;
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void reload_gateway_req::set_allocated_host(::std::string* host) {
  if (host_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete host_;
  }
  if (host) {
    set_has_host();
    host_ = host;
  } else {
    clear_has_host();
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:nway_fs_opterator.reload_gateway_req.host)
}

// optional string port = 2;
inline bool reload_gateway_req::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void reload_gateway_req::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void reload_gateway_req::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void reload_gateway_req::clear_port() {
  if (port_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    port_->clear();
  }
  clear_has_port();
}
inline const ::std::string& reload_gateway_req::port() const {
  // @@protoc_insertion_point(field_get:nway_fs_opterator.reload_gateway_req.port)
  return *port_;
}
inline void reload_gateway_req::set_port(const ::std::string& value) {
  set_has_port();
  if (port_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    port_ = new ::std::string;
  }
  port_->assign(value);
  // @@protoc_insertion_point(field_set:nway_fs_opterator.reload_gateway_req.port)
}
inline void reload_gateway_req::set_port(const char* value) {
  set_has_port();
  if (port_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    port_ = new ::std::string;
  }
  port_->assign(value);
  // @@protoc_insertion_point(field_set_char:nway_fs_opterator.reload_gateway_req.port)
}
inline void reload_gateway_req::set_port(const char* value, size_t size) {
  set_has_port();
  if (port_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    port_ = new ::std::string;
  }
  port_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nway_fs_opterator.reload_gateway_req.port)
}
inline ::std::string* reload_gateway_req::mutable_port() {
  set_has_port();
  if (port_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    port_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:nway_fs_opterator.reload_gateway_req.port)
  return port_;
}
inline ::std::string* reload_gateway_req::release_port() {
  clear_has_port();
  if (port_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = port_;
    port_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void reload_gateway_req::set_allocated_port(::std::string* port) {
  if (port_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete port_;
  }
  if (port) {
    set_has_port();
    port_ = port;
  } else {
    clear_has_port();
    port_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:nway_fs_opterator.reload_gateway_req.port)
}

// optional string password = 3;
inline bool reload_gateway_req::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void reload_gateway_req::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void reload_gateway_req::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void reload_gateway_req::clear_password() {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& reload_gateway_req::password() const {
  // @@protoc_insertion_point(field_get:nway_fs_opterator.reload_gateway_req.password)
  return *password_;
}
inline void reload_gateway_req::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set:nway_fs_opterator.reload_gateway_req.password)
}
inline void reload_gateway_req::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set_char:nway_fs_opterator.reload_gateway_req.password)
}
inline void reload_gateway_req::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nway_fs_opterator.reload_gateway_req.password)
}
inline ::std::string* reload_gateway_req::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:nway_fs_opterator.reload_gateway_req.password)
  return password_;
}
inline ::std::string* reload_gateway_req::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void reload_gateway_req::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:nway_fs_opterator.reload_gateway_req.password)
}

// -------------------------------------------------------------------

// reload_gateway_rsp

// required .nway_fs_opterator.nway_op_status status = 1;
inline bool reload_gateway_rsp::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void reload_gateway_rsp::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void reload_gateway_rsp::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void reload_gateway_rsp::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::nway_fs_opterator::nway_op_status reload_gateway_rsp::status() const {
  // @@protoc_insertion_point(field_get:nway_fs_opterator.reload_gateway_rsp.status)
  return static_cast< ::nway_fs_opterator::nway_op_status >(status_);
}
inline void reload_gateway_rsp::set_status(::nway_fs_opterator::nway_op_status value) {
  assert(::nway_fs_opterator::nway_op_status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:nway_fs_opterator.reload_gateway_rsp.status)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace nway_fs_opterator

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::nway_fs_opterator::nway_op_status> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nway_fs_opterator::nway_op_status>() {
  return ::nway_fs_opterator::nway_op_status_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_gateway_5fop_2eproto__INCLUDED
